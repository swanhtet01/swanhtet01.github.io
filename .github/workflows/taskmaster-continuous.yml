name: "ğŸ¯ Taskmaster AI - Continuous Learning System (24/7 FREE)"
on:
  schedule:
    # Run every 2 minutes to maximize free tier usage
    - cron: '*/2 * * * *'
  workflow_dispatch:
    inputs:
      duration:
        description: 'Duration in minutes'
        required: false
        default: '120'
        type: string
      intensity:
        description: 'Learning intensity (1-10)'
        required: false
        default: '7'
        type: string

jobs:
  continuous-learning:
    runs-on: ubuntu-latest
    timeout-minutes: 5  # Short cycles to stay within limits
    
    strategy:
      matrix:
        learning_focus: ['technical-skills', 'soft-skills', 'challenges', 'peer-learning']
    
    steps:
    - name: ğŸ¯ Checkout Repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: ğŸ Setup Python Environment
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
        
    - name: ğŸ“¦ Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests asyncio sqlite3 psutil pathlib
        
    - name: ğŸ¯ Initialize Taskmaster AI
      run: |
        echo "ğŸ¯ Taskmaster AI - Continuous Learning Cycle"
        echo "Focus: ${{ matrix.learning_focus }}"
        echo "Current Time: $(date)"
        echo "GitHub Actions Minutes Used: Maximizing FREE tier"
        
        # Create learning environment
        mkdir -p learning_logs reports progress_tracking
        
    - name: ğŸ§  Execute Learning Cycle
      run: |
        python - << 'EOF'
        import asyncio
        import json
        import sqlite3
        import os
        import random
        from datetime import datetime, timedelta
        
        class QuickLearningCycle:
            def __init__(self, focus_area):
                self.focus_area = focus_area
                self.cycle_start = datetime.now()
                self.agents = {
                    'alex': {'level': 67, 'focus': 'architecture', 'learning_rate': 1.2},
                    'maria': {'level': 71, 'focus': 'fullstack', 'learning_rate': 1.1}, 
                    'james': {'level': 64, 'focus': 'testing', 'learning_rate': 1.3},
                    'sarah': {'level': 69, 'focus': 'analytics', 'learning_rate': 1.15},
                    'neo': {'level': 95, 'focus': 'teaching', 'learning_rate': 1.5}
                }
                self.skills_learned = []
                self.challenges_completed = []
                
            async def run_learning_cycle(self):
                print(f"ğŸš€ Starting {self.focus_area} learning cycle...")
                
                if self.focus_area == 'technical-skills':
                    await self.technical_learning()
                elif self.focus_area == 'soft-skills':
                    await self.soft_skills_learning()
                elif self.focus_area == 'challenges':
                    await self.challenge_completion()
                elif self.focus_area == 'peer-learning':
                    await self.peer_learning_session()
                
                await self.save_progress()
                await self.generate_micro_report()
                
                duration = (datetime.now() - self.cycle_start).total_seconds()
                print(f"âœ… Cycle completed in {duration:.1f} seconds")
                
            async def technical_learning(self):
                """Simulate technical skill learning"""
                technical_skills = [
                    'Advanced Python Patterns', 'Microservices Architecture',
                    'Machine Learning Algorithms', 'Cloud Security',
                    'Performance Optimization', 'Database Sharding'
                ]
                
                for agent, info in self.agents.items():
                    skill = random.choice(technical_skills)
                    learning_gain = random.uniform(0.5, 2.0) * info['learning_rate']
                    
                    self.skills_learned.append({
                        'agent': agent,
                        'skill': skill,
                        'gain': learning_gain,
                        'timestamp': datetime.now().isoformat()
                    })
                    
                    info['level'] = min(100, info['level'] + learning_gain * 0.1)
                    print(f"  ğŸ“š {agent} learned {skill} (+{learning_gain:.1f} XP)")
                
            async def soft_skills_learning(self):
                """Simulate soft skills development"""
                soft_skills = [
                    'Team Leadership', 'Code Review Techniques',
                    'Mentoring', 'Technical Communication',
                    'Project Planning', 'Conflict Resolution'
                ]
                
                for agent, info in self.agents.items():
                    if agent != 'neo':  # Neo teaches others
                        skill = random.choice(soft_skills)
                        learning_gain = random.uniform(0.3, 1.5) * info['learning_rate']
                        
                        self.skills_learned.append({
                            'agent': agent,
                            'skill': skill,
                            'gain': learning_gain,
                            'mentor': 'neo',
                            'timestamp': datetime.now().isoformat()
                        })
                        
                        info['level'] += learning_gain * 0.08
                        print(f"  ğŸ¤ {agent} improved {skill} with Neo's guidance (+{learning_gain:.1f})")
                        
            async def challenge_completion(self):
                """Simulate challenge completion"""
                challenges = [
                    {'name': 'Algorithm Optimization', 'difficulty': 7, 'points': 500},
                    {'name': 'Security Audit', 'difficulty': 8, 'points': 750},
                    {'name': 'ML Model Training', 'difficulty': 9, 'points': 1000},
                    {'name': 'System Design', 'difficulty': 6, 'points': 400}
                ]
                
                # Select agents for challenges based on their levels
                eligible_agents = [name for name, info in self.agents.items() 
                                 if info['level'] > 60 and name != 'neo']
                
                for _ in range(min(2, len(eligible_agents))):
                    agent = random.choice(eligible_agents)
                    challenge = random.choice(challenges)
                    
                    success_rate = min(0.9, self.agents[agent]['level'] / 100)
                    if random.random() < success_rate:
                        self.challenges_completed.append({
                            'agent': agent,
                            'challenge': challenge['name'],
                            'points': challenge['points'],
                            'timestamp': datetime.now().isoformat()
                        })
                        
                        self.agents[agent]['level'] += challenge['points'] * 0.01
                        print(f"  ğŸ† {agent} completed {challenge['name']} (+{challenge['points']} points)")
                        
            async def peer_learning_session(self):
                """Simulate peer learning"""
                learning_pairs = [
                    ('alex', 'maria'), ('maria', 'james'), 
                    ('james', 'sarah'), ('sarah', 'alex')
                ]
                
                for mentor, student in learning_pairs:
                    if self.agents[mentor]['level'] > self.agents[student]['level']:
                        skill_transfer = random.uniform(0.2, 0.8)
                        
                        self.skills_learned.append({
                            'mentor': mentor,
                            'student': student,
                            'knowledge_transfer': skill_transfer,
                            'timestamp': datetime.now().isoformat()
                        })
                        
                        self.agents[student]['level'] += skill_transfer * 0.05
                        print(f"  ğŸ¤ {mentor} taught {student} (+{skill_transfer:.1f} knowledge transfer)")
                        
            async def save_progress(self):
                """Save learning progress to file"""
                progress_data = {
                    'cycle_focus': self.focus_area,
                    'timestamp': self.cycle_start.isoformat(),
                    'agents': self.agents,
                    'skills_learned': self.skills_learned,
                    'challenges_completed': self.challenges_completed,
                    'cycle_duration': (datetime.now() - self.cycle_start).total_seconds()
                }
                
                # Save to GitHub repository
                filename = f"learning_logs/cycle_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{self.focus_area}.json"
                with open(filename, 'w') as f:
                    json.dump(progress_data, f, indent=2)
                    
                print(f"ğŸ’¾ Progress saved to {filename}")
                
            async def generate_micro_report(self):
                """Generate micro learning report"""
                report = f"""
        # ğŸ¯ Taskmaster Learning Micro-Report
        
        **Focus Area:** {self.focus_area}
        **Cycle Time:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
        
        ## ğŸ“Š Agent Levels
        """
                
                for agent, info in self.agents.items():
                    report += f"- **{agent.title()}:** Level {info['level']:.1f} (Focus: {info['focus']})\n"
                
                if self.skills_learned:
                    report += f"\n## ğŸ“š Skills Learned ({len(self.skills_learned)})\n"
                    for skill in self.skills_learned[-3:]:  # Show last 3
                        report += f"- {skill.get('agent', skill.get('student', 'Unknown'))}: {skill.get('skill', 'Knowledge Transfer')}\n"
                
                if self.challenges_completed:
                    report += f"\n## ğŸ† Challenges Completed ({len(self.challenges_completed)})\n"
                    for challenge in self.challenges_completed:
                        report += f"- {challenge['agent']}: {challenge['challenge']} ({challenge['points']} pts)\n"
                        
                report += f"\n**Next Cycle:** In 2 minutes\n**Status:** Learning never stops! ğŸš€\n"
                
                with open('reports/latest_micro_report.md', 'w') as f:
                    f.write(report)
                    
                print("ğŸ“‹ Micro-report generated")
        
        # Run the learning cycle
        async def main():
            focus_area = "${{ matrix.learning_focus }}"
            cycle = QuickLearningCycle(focus_area)
            await cycle.run_learning_cycle()
        
        asyncio.run(main())
        EOF
        
    - name: ğŸ“Š Update Progress Dashboard
      run: |
        python - << 'EOF'
        import json
        import os
        from datetime import datetime
        import glob
        
        # Aggregate all learning data
        total_skills = 0
        total_challenges = 0
        latest_levels = {}
        
        log_files = glob.glob('learning_logs/*.json')
        
        for log_file in log_files:
            try:
                with open(log_file, 'r') as f:
                    data = json.load(f)
                    total_skills += len(data.get('skills_learned', []))
                    total_challenges += len(data.get('challenges_completed', []))
                    
                    # Update latest agent levels
                    for agent, info in data.get('agents', {}).items():
                        latest_levels[agent] = info.get('level', 0)
            except:
                continue
        
        # Generate dashboard
        dashboard = f"""
        # ğŸ¯ Taskmaster AI - Continuous Learning Dashboard
        
        **Last Update:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
        
        ## ğŸ“ˆ Learning Statistics
        - **Total Skills Learned:** {total_skills}
        - **Challenges Completed:** {total_challenges}
        - **Learning Cycles:** {len(log_files)}
        - **Operational Time:** 24/7 Continuous
        
        ## ğŸ‘¥ Agent Levels
        """
        
        for agent, level in latest_levels.items():
            dashboard += f"- **{agent.title()}:** Level {level:.1f}\n"
            
        dashboard += f"""
        
        ## ğŸš€ System Status
        - **Mode:** Continuous Learning (Every 2 minutes)
        - **Cost:** $0.00 (GitHub Actions FREE)
        - **Focus:** Technical Skills, Soft Skills, Challenges, Peer Learning
        - **Next Cycle:** Auto-scheduled
        
        ---
        *Taskmaster AI pushes FREE tiers to maximum limits for continuous team improvement*
        """
        
        with open('TASKMASTER_DASHBOARD.md', 'w') as f:
            f.write(dashboard)
            
        print("ğŸ“Š Dashboard updated successfully")
        EOF
        
    - name: ğŸ’¾ Commit Learning Progress
      run: |
        git config --local user.email "taskmaster-ai@supermega.com"
        git config --local user.name "Taskmaster AI Bot"
        
        git add -A
        
        if ! git diff --cached --exit-code; then
          git commit -m "ğŸ¯ Taskmaster AI: ${{ matrix.learning_focus }} learning cycle $(date '+%Y-%m-%d %H:%M')"
          git push origin main
          echo "âœ… Learning progress committed and pushed"
        else
          echo "â„¹ï¸ No new learning progress to commit"
        fi
        
    - name: ğŸ”„ Schedule Next Learning Cycle
      run: |
        echo "â° Next learning cycle scheduled:"
        echo "  Focus Areas: technical-skills, soft-skills, challenges, peer-learning"
        echo "  Frequency: Every 2 minutes"
        echo "  Total FREE minutes used efficiently"
        echo "  Status: Continuous learning never stops! ğŸš€"
        
  intensive-learning:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    timeout-minutes: 60
    
    steps:
    - name: ğŸ¯ Intensive Learning Session
      run: |
        duration=${{ github.event.inputs.duration }}
        intensity=${{ github.event.inputs.intensity }}
        
        echo "ğŸš€ Starting intensive learning session"
        echo "Duration: ${duration} minutes"
        echo "Intensity: ${intensity}/10"
        
        # Simulate intensive learning
        python - << EOF
        import asyncio
        import random
        import time
        from datetime import datetime, timedelta
        
        async def intensive_learning():
            duration = int("$duration")
            intensity = int("$intensity")
            
            print(f"ğŸ§  Intensive learning for {duration} minutes at intensity {intensity}")
            
            # Calculate cycles based on intensity
            cycles = duration * intensity // 2
            
            for cycle in range(cycles):
                print(f"ğŸ”„ Intensive cycle {cycle + 1}/{cycles}")
                
                # Simulate advanced learning
                skills = ['Advanced AI', 'Quantum Computing', 'Blockchain', 'Edge Computing']
                agents = ['alex', 'maria', 'james', 'sarah', 'neo']
                
                for agent in agents:
                    skill = random.choice(skills)
                    learning_boost = random.uniform(2.0, 5.0) * (intensity / 10)
                    print(f"  âš¡ {agent} mastering {skill} (+{learning_boost:.1f} intensive XP)")
                
                await asyncio.sleep(0.5)  # Brief pause
                
            print(f"âœ… Intensive learning completed: {cycles} cycles in {duration} minutes")
        
        asyncio.run(intensive_learning())
        EOF
