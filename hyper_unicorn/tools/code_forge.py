import os
from e2b import Sandbox
from github import Github

class CodeForge:
    def __init__(self):
        self.github_token = os.getenv("GITHUB_TOKEN")
        self.e2b_api_key = os.getenv("E2B_API_KEY")
        self.gh = Github(self.github_token)

    def plan_project(self, requirements: str):
        """Uses an LLM to create a project plan from requirements."""
        # This would call a powerful LLM (like Claude 3.5 Sonnet)
        # to break down the requirements into a file structure, dependencies,
        # and a step-by-step implementation plan.
        plan = {
            "files": [
                {"name": "main.py", "description": "Main application entry point"},
                {"name": "utils.py", "description": "Utility functions"},
                {"name": "README.md", "description": "Project documentation"}
            ],
            "dependencies": ["fastapi", "uvicorn"],
            "steps": [
                "1. Create file structure.",
                "2. Write code for utils.py.",
                "3. Write code for main.py.",
                "4. Write README.md.",
                "5. Install dependencies.",
                "6. Run tests.",
                "7. Commit to GitHub."
            ]
        }
        return plan

    def execute_plan(self, plan: dict, repo_name: str):
        """Executes the development plan in a secure E2B sandbox."""
        with Sandbox(api_key=self.e2b_api_key) as sandbox:
            # 1. Create file structure
            for file_info in plan["files"]:
                sandbox.filesystem.write(file_info["name"], "# Placeholder")
            print("File structure created.")

            # 2. Generate and write code (simulated)
            # In a real scenario, an LLM would generate the code for each file
            # based on the plan and requirements.
            main_py_code = """
from fastapi import FastAPI
import utils

app = FastAPI()

@app.get("/")
def read_root():
    return {"message": utils.get_message()}
"""
            utils_py_code = """
def get_message():
    return "Hello from Code Forge!"
"""
            readme_code = f"# {repo_name}\n\nThis project was auto-generated by the Code Forge mega tool."

            sandbox.filesystem.write("main.py", main_py_code)
            sandbox.filesystem.write("utils.py", utils_py_code)
            sandbox.filesystem.write("README.md", readme_code)
            print("Code generated and written.")

            # 3. Install dependencies
            requirements = "\n".join(plan["dependencies"])
            sandbox.filesystem.write("requirements.txt", requirements)
            proc = sandbox.process.start("pip install -r requirements.txt")
            proc.wait()
            print("Dependencies installed.")

            # 4. Run tests (simulated)
            # A real implementation would run pytest or a similar framework
            print("Tests passed (simulated).")

            # 5. Commit to GitHub
            self.commit_to_github(sandbox, repo_name, plan)
            print(f"Project committed to GitHub repo: {repo_name}")

        return {"status": "success", "repo_url": f"https://github.com/{self.get_user().login}/{repo_name}"}

    def get_user(self):
        return self.gh.get_user()

    def commit_to_github(self, sandbox, repo_name, plan):
        """Commits the generated code from the sandbox to a GitHub repository."""
        try:
            user = self.get_user()
            repo = user.create_repo(repo_name, private=True)
            print(f"Created repo: {repo.full_name}")
        except Exception as e:
            print(f"Repo already exists or failed to create: {e}")
            repo = self.gh.get_repo(f"{user.login}/{repo_name}")

        # In a real implementation, we would clone the repo into the sandbox,
        # copy the files, and push. For this example, we will create files directly.
        for file_info in plan["files"]:
            content = sandbox.filesystem.read(file_info["name"])
            try:
                # Check if file exists to update it
                existing_file = repo.get_contents(file_info["name"])
                file_name = file_info["name"]
                repo.update_file(existing_file.path, f"Update {file_name}", content, existing_file.sha)
            except Exception:
                # Create file if it doesn\'t exist
                file_name = file_info["name"]
                repo.create_file(file_name, f"Create {file_name}", content)

# Example Usage:
def main():
    # Note: Requires GITHUB_TOKEN and E2B_API_KEY environment variables
    code_forge = CodeForge()
    requirements = "Create a simple FastAPI web server with a single endpoint that returns a message."
    repo_name = "fastapi-hello-world-generated"

    print("--- Planning project ---")
    plan = code_forge.plan_project(requirements)
    print(plan)

    print("\n--- Executing plan ---")
    result = code_forge.execute_plan(plan, repo_name)
    print(f"\n--- Result ---")
    print(result)

if __name__ == "__main__":
    main()
